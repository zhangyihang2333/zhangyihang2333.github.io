<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://zhangyihang2333.github.io').hostname,
    root: '/',
    scheme: 'Pisces',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="前段时间没有什么可以干的事 咸鱼而没有追求的日子里居然啃完了一本Datasheet!!!">
<meta property="og:type" content="article">
<meta property="og:title" content="FREERTOS学习总结">
<meta property="og:url" content="https://zhangyihang2333.github.io/2020/03/21/FREERTOS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Evolver">
<meta property="og:description" content="前段时间没有什么可以干的事 咸鱼而没有追求的日子里居然啃完了一本Datasheet!!!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhangyihang2333.github.io/images/FREERTOS.png">
<meta property="article:published_time" content="2020-03-21T14:25:20.000Z">
<meta property="article:modified_time" content="2020-03-21T14:34:39.321Z">
<meta property="article:author" content="张怡航">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhangyihang2333.github.io/images/FREERTOS.png">

<link rel="canonical" href="https://zhangyihang2333.github.io/2020/03/21/FREERTOS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>FREERTOS学习总结 | Evolver</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script type="text/javascript" src="/js/love.js"></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="  ">
    <div class="headband"></div>

<a href="https://github.com//zhangyihang2333" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Evolver</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhangyihang2333.github.io/2020/03/21/FREERTOS%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/apple-touch-icon-next.png">
      <meta itemprop="name" content="张怡航">
      <meta itemprop="description" content="今天懒惰小张敲代码了吗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Evolver">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          FREERTOS学习总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-03-21 22:25:20 / 修改时间：22:34:39" itemprop="dateCreated datePublished" datetime="2020-03-21T22:25:20+08:00">2020-03-21</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>前段时间没有什么可以干的事 咸鱼而没有追求的日子里居然啃完了一本Datasheet!!!<br><img src="/images/FREERTOS.png" alt></p>
<a id="more"></a>
<h1 id="FREERTOS"><a href="#FREERTOS" class="headerlink" title="FREERTOS"></a>FREERTOS</h1><h2 id="FreeRtos任务管理"><a href="#FreeRtos任务管理" class="headerlink" title="FreeRtos任务管理"></a>FreeRtos任务管理</h2><h3 id="单任务系统·"><a href="#单任务系统·" class="headerlink" title="单任务系统·"></a>单任务系统·</h3><ul>
<li><p>查询方式</p>
<ul>
<li>无法定义查询任务的优先级</li>
<li>重要的接口消息得不到及时响应</li>
</ul>
</li>
<li><p>中断方式</p>
<ul>
<li><p>必须在中断（ISR）内处理时间关键运算</p>
<ul>
<li><p>ISR函数变得复杂 逻辑变得难以理解</p>
</li>
<li><p>ISR嵌套可能产生不可预测的执行时间和堆栈需求</p>
<ul>
<li>软件开销较大</li>
</ul>
</li>
</ul>
</li>
<li><p>应用程序的数据交换是通过全局变量进行</p>
<ul>
<li>程序员必须确保数据的一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多任务系统"><a href="#多任务系统" class="headerlink" title="多任务系统"></a>多任务系统</h3><ul>
<li><p>使用相关调度算法决定当前需要执行的任务</p>
<ul>
<li>多任务是在某一时刻只能有一个任务运行，只是通过调度器的决策，看起来所有任务同时运行</li>
</ul>
</li>
<li><p>实时操作系统</p>
<ul>
<li>抢占式调度</li>
<li>时间片式调度</li>
<li>合作式调度</li>
</ul>
</li>
</ul>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul>
<li>系统栈空间</li>
<li>任务栈空间</li>
</ul>
<h3 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h3><ul>
<li>Running–运行态</li>
<li>Ready–就绪态</li>
<li>Blocked–阻塞态</li>
<li>Suspended–挂起态</li>
</ul>
<h3 id="任务管理函数"><a href="#任务管理函数" class="headerlink" title="任务管理函数"></a>任务管理函数</h3><ul>
<li><p>vTaskStartScheduler()  –启动 FreeRTOS</p>
<ul>
<li>在创建完任务后进行开始任务调度</li>
</ul>
</li>
<li><p>xTaskCreate() –实现 FreeRTOS 操作系统的任务创建</p>
</li>
<li><p>vTaskDelete – 实现 FreeRTOS 操作系统的任务删除</p>
</li>
<li><p>vTaskSuspend–实现 FreeRTOS 操作系统的任务挂起。</p>
</li>
<li><p>实现 FreeRTOS 操作系统的任务恢复</p>
<ul>
<li>xTaskResume()</li>
<li>xTaskResumeFromISR()  中断方式</li>
</ul>
</li>
</ul>
<h2 id="FreeRtos任务栈大小"><a href="#FreeRtos任务栈大小" class="headerlink" title="FreeRtos任务栈大小"></a>FreeRtos任务栈大小</h2><h3 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><ul>
<li><p>函数的局部变量</p>
</li>
<li><p>函数形参</p>
<ul>
<li>嵌套的函数所使用的形参d</li>
</ul>
</li>
<li><p>函数返回地址</p>
<ul>
<li>对于M3和M4内核的MCU 函数的返回地址是专门保存到寄存器里面的</li>
</ul>
</li>
</ul>
<h3 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h3><h3 id="对于M3和M4内核的MCU-任务执行过程中发生中断"><a href="#对于M3和M4内核的MCU-任务执行过程中发生中断" class="headerlink" title="对于M3和M4内核的MCU 任务执行过程中发生中断"></a>对于M3和M4内核的MCU 任务执行过程中发生中断</h3><ul>
<li>M3 内核的 MCU 有 8 个寄存器是自动入栈的，这个栈是任务栈，进入中断以后其余寄存器入栈<br>以及发生中断嵌套都是用的系统栈。</li>
<li>M4 内核的 MCU 有 8 个通用寄存器和 18 个浮点寄存器是自动入栈的，这个栈是任务栈，进入<br>中断以后其余通用寄存器和浮点寄存器入栈以及发生中断嵌套都是用的系统栈。</li>
<li>进入中断以后使用的局部变量以及可能发生的中断嵌套都是用的系统栈</li>
</ul>
<h3 id="栈溢出检测"><a href="#栈溢出检测" class="headerlink" title="栈溢出检测"></a>栈溢出检测</h3><ul>
<li><p>在任务切换时检测任务栈指针是否过界了，如果过界了，在任务切换的时候会触发栈溢出钩子函<br>数</p>
<ul>
<li>void vApplicationStackOverflowHook( TaskHandle_t xTask,signed char *pcTaskName );</li>
</ul>
</li>
<li><p>任务创建的时候将任务栈所有数据初始化为 0xa5，任务切换时进行任务栈检测的时候会检测末<br>尾的 16 个字节是否都是 0xa5，通过这种方式来检测任务栈是否溢出了。</p>
</li>
</ul>
<h2 id="FreeRtos中断优先级"><a href="#FreeRtos中断优先级" class="headerlink" title="FreeRtos中断优先级"></a>FreeRtos中断优先级</h2><h3 id="NVIC基础知识—-gt-嵌套向量中断控制器"><a href="#NVIC基础知识—-gt-嵌套向量中断控制器" class="headerlink" title="NVIC基础知识—-&gt;嵌套向量中断控制器"></a>NVIC基础知识—-&gt;嵌套向量中断控制器</h3><ul>
<li><p>NVIC相关寄存器操作</p>
</li>
<li><p>优先级分组</p>
<ul>
<li>NVIC_PriorityGroup_0</li>
<li>NVIC_PriorityGroup_1</li>
<li>NVIC_PriorityGroup_2</li>
<li>NVIC_PriorityGroup_3</li>
<li>NVIC_PriorityGroup_4</li>
</ul>
</li>
</ul>
<h3 id="开关中断实现机制"><a href="#开关中断实现机制" class="headerlink" title="开关中断实现机制"></a>开关中断实现机制</h3><ul>
<li><p>primask</p>
<ul>
<li>在它被置 1 后，就关掉所有可屏蔽的异常，只剩下<br>NMI 和硬 fault 可以响应。它的缺省值是 0，表示没有关中断。</li>
</ul>
</li>
<li><p>faultmask</p>
<ul>
<li>当它置 1 时，只有 NMI 才能响应，所有其它的异<br>常，甚至是硬 fault，也通通闭嘴。它的缺省值也是 0，表示没有关异常</li>
</ul>
</li>
<li><p>basepri</p>
<ul>
<li>当它被设成某个值后，所有优先级号大于等于此值的中断都被关（优先级号越大，优<br>先级越低）。但若被设成 0，则不关闭任何中断， 0 也是缺省值。</li>
</ul>
</li>
</ul>
<h2 id="任务抢占优先级及其分配方案"><a href="#任务抢占优先级及其分配方案" class="headerlink" title="任务抢占优先级及其分配方案"></a>任务抢占优先级及其分配方案</h2><h3 id="任务优先级和中断优先级"><a href="#任务优先级和中断优先级" class="headerlink" title="任务优先级和中断优先级"></a>任务优先级和中断优先级</h3><ul>
<li>任务优先级的数值越小，任务优先级越低</li>
<li>中断优先级的数值越小，优先级越高</li>
</ul>
<h3 id="任务优先级分配方案"><a href="#任务优先级分配方案" class="headerlink" title="任务优先级分配方案"></a>任务优先级分配方案</h3><ul>
<li><p>IRQ任务</p>
<ul>
<li>中断服务程序进行触发的任务 所有优先级中最高的</li>
</ul>
</li>
<li><p>高优先级后台任务</p>
<ul>
<li>按键检测</li>
<li>触摸检测</li>
<li>USB消息处理</li>
</ul>
</li>
<li><p>低优先级的时间片调度任务</p>
<ul>
<li>不太需要实时执行的任务</li>
</ul>
</li>
<li><p>空闲任务</p>
</li>
</ul>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ul>
<li>任务优先级修改   vTaskPrioritySet ()</li>
<li>任务优先级获取  vTaskPriorityGet ()</li>
</ul>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><h3 id="抢占式调度器"><a href="#抢占式调度器" class="headerlink" title="抢占式调度器"></a>抢占式调度器</h3><ul>
<li><p>每个任务都有不同的优先级， 任务会一直运行直到被高优先级任务抢占或者遇到阻塞式的 API 函数，</p>
<ul>
<li>每个任务被分配以不同的优先级，抢占式调度器从就绪列表中火得优先级最高的任务并运行</li>
</ul>
</li>
</ul>
<h3 id="时间片调度器"><a href="#时间片调度器" class="headerlink" title="时间片调度器"></a>时间片调度器</h3><ul>
<li><p>每个任务都有相同的优先级， 任务会运行固定的时间片个数或者遇到阻塞式的 API 函数</p>
<ul>
<li>时间片调度发生在相同优先级任务之间</li>
<li>每个任务分配一个时间片（ 也就是需要运行的时间长度，时间片用完了就进行任务切换）</li>
</ul>
</li>
</ul>
<h3 id="合作式调度器"><a href="#合作式调度器" class="headerlink" title="合作式调度器"></a>合作式调度器</h3><ul>
<li>官方文档曾进行了特别的说明，之后不再升级，故已经使用得很少了</li>
</ul>
<h2 id="FreeRtos临界段和开关中断"><a href="#FreeRtos临界段和开关中断" class="headerlink" title="FreeRtos临界段和开关中断"></a>FreeRtos临界段和开关中断</h2><h3 id="临界段，一但该部分代码开始执行，则不允许中断打断"><a href="#临界段，一但该部分代码开始执行，则不允许中断打断" class="headerlink" title="临界段，一但该部分代码开始执行，则不允许中断打断"></a>临界段，一但该部分代码开始执行，则不允许中断打断</h3><ul>
<li><p>进入临界段代码之前关闭中断</p>
<ul>
<li>taskENTER_CRITICAL 进入临界段</li>
<li>portSET_INTERRUPT_MASK_FROM_ISR(); </li>
</ul>
</li>
<li><p>执行临界段代码</p>
<ul>
<li>嵌套计数</li>
</ul>
</li>
<li><p>执行完毕 开启中断</p>
<ul>
<li>taskEXIT_CRITICAL退出临界段</li>
<li>portCLEAR_INTERRUPT_MASK_FROM_ISR(  )</li>
</ul>
</li>
</ul>
<h3 id="影响系统的实时性"><a href="#影响系统的实时性" class="headerlink" title="影响系统的实时性"></a>影响系统的实时性</h3><h2 id="FreeRtos调度锁-任务锁和中断锁"><a href="#FreeRtos调度锁-任务锁和中断锁" class="headerlink" title="FreeRtos调度锁 任务锁和中断锁"></a>FreeRtos调度锁 任务锁和中断锁</h2><h3 id="调度锁"><a href="#调度锁" class="headerlink" title="调度锁"></a>调度锁</h3><ul>
<li><p>调度锁禁止任务调度，中断还是可以正常执行的</p>
<ul>
<li>xTaskResumeAll 用于实现 FreeRTOS 调度锁关闭</li>
<li>vTaskSuspendAll 用于实现 FreeRTOS 调度锁开启</li>
</ul>
</li>
<li><p>代码执行期间不会被高优先级任务抢占</p>
</li>
</ul>
<h3 id="中断锁"><a href="#中断锁" class="headerlink" title="中断锁"></a>中断锁</h3><ul>
<li>FreeRtos没有专门的中断锁函数</li>
<li>使用中断服务程序临界段处理函数实现同样效果</li>
</ul>
<h3 id="任务锁"><a href="#任务锁" class="headerlink" title="任务锁"></a>任务锁</h3><ul>
<li>给调度器加锁，关闭任务切换功能  </li>
</ul>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><h3 id="动态内存管理是FreeRtos非常重要的一项功能-所有需要RAM空间都是通过动态内存管理从FreeRTOSconfig-h文件定义的heap空间中申请的"><a href="#动态内存管理是FreeRtos非常重要的一项功能-所有需要RAM空间都是通过动态内存管理从FreeRTOSconfig-h文件定义的heap空间中申请的" class="headerlink" title="动态内存管理是FreeRtos非常重要的一项功能 所有需要RAM空间都是通过动态内存管理从FreeRTOSconfig.h文件定义的heap空间中申请的"></a>动态内存管理是FreeRtos非常重要的一项功能 所有需要RAM空间都是通过动态内存管理从FreeRTOSconfig.h文件定义的heap空间中申请的</h3><h3 id="FreeRTOS支持五种动态内存管理方案"><a href="#FreeRTOS支持五种动态内存管理方案" class="headerlink" title="FreeRTOS支持五种动态内存管理方案"></a>FreeRTOS支持五种动态内存管理方案</h3><ul>
<li><p>Heap_1</p>
<ul>
<li>项目应用不需要删除任务、 信号量、 消息队列等已经创建的资源。</li>
<li>具有时间确定性，即申请动态内存的时间是固定的并且不会产生内存碎片</li>
<li>确切的说这是一种静态内存分配，因为申请的内存是不允许被释放掉的</li>
</ul>
</li>
<li><p>Heap_2</p>
<ul>
<li><p>利用最适应算法</p>
<ul>
<li><p>支持内存释放</p>
<ul>
<li>不考虑内存碎片的情况下，这种方式支持重复的任务、 信号量、 事件标志组、 软件定时器等内部资源的创建和删除</li>
</ul>
</li>
<li><p>不支持内存碎片整理</p>
<ul>
<li>用户随机的创建和删除任务、 消息队列、 事件标志组、 信号量等内部资源也容易出现内存碎片</li>
<li>直接的调用函数 pvPortMalloc() 和 vPortFree()也容易出现内存碎片</li>
<li>heap_2 方式实现的动态内存申请不具有时间确定性，但是比 C 库中的 malloc 函数效率要高</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Heap_3</p>
<ul>
<li><p>对编译器提供的 malloc 和 free 函数进行了封装，保证是线程安全的</p>
<ul>
<li>需要编译器提供 malloc 和 free 函数</li>
<li>不具有时间确定性，即申请动态内存的时间不是固定的</li>
<li>增加 RTOS 内核的代码量</li>
</ul>
</li>
</ul>
</li>
<li><p>Heap_4</p>
<ul>
<li><p>利用最适应算法</p>
<ul>
<li><p>支持内存碎片的回<br>收并将其整理为一个大的内存块</p>
<ul>
<li>可以用于需要重复的创建和删任务、 信号量、 事件标志组、 软件定时器等内部资源的场合</li>
<li>随机的调用 pvPortMalloc() 和 vPortFree()，且每次申请的大小都不同，也不会像 heap_2 那样产<br>生很多的内存碎片</li>
<li>不具有时间确定性， 即申请动态内存的时间不是确定的，但是比 C 库中的 malloc 函数要高效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Heap_5</p>
<ul>
<li>在Heap_4的基础上做一些优化</li>
</ul>
</li>
</ul>
<h2 id="任务消息邮箱"><a href="#任务消息邮箱" class="headerlink" title="任务消息邮箱"></a>任务消息邮箱</h2><h2 id="任务通知"><a href="#任务通知" class="headerlink" title="任务通知"></a>任务通知</h2><h3 id="TCB（task-control-block）任务控制块中一个-32-位的变量成员-ulNotifiedValue-是专门"><a href="#TCB（task-control-block）任务控制块中一个-32-位的变量成员-ulNotifiedValue-是专门" class="headerlink" title="TCB（task control block）任务控制块中一个 32 位的变量成员 ulNotifiedValue 是专门"></a>TCB（task control block）任务控制块中一个 32 位的变量成员 ulNotifiedValue 是专门</h3><p>用于任务通知的。</p>
<ul>
<li><p>任务通知</p>
<ul>
<li><p>计数信号量</p>
<ul>
<li>接收任务控制块中的变量 ulNotifiedValue 数值进行加一或者减一操作可以实现计数信号量和二<br>值信号量</li>
</ul>
</li>
<li><p>二值信号量</p>
</li>
<li><p>事件标志组</p>
<ul>
<li>设置接收任务控制块中的变量 ulNotifiedValue 的 bit0-bit31 数值可以实现事件标志组</li>
</ul>
</li>
<li><p>消息邮箱 （消息队列长度为1）</p>
<ul>
<li>设置接收任务控制块中的变量 ulNotifiedValue 可以实现消息邮箱</li>
<li>如果接收任务控制块中的变量 ulNotifiedValue 还没有被其接收到， 也可以用新数据覆盖原有数据<br>， 这就是覆盖方式的消息邮箱。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="任务事件标志组"><a href="#任务事件标志组" class="headerlink" title="任务事件标志组"></a>任务事件标志组</h2><h3 id="BaseType-t-xTaskNotify-TaskHandle-t-xTaskToNotify-任务句柄"><a href="#BaseType-t-xTaskNotify-TaskHandle-t-xTaskToNotify-任务句柄" class="headerlink" title="BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, /* 任务句柄 */"></a>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, /* 任务句柄 */</h3><p>uint32_t ulValue, /* 更新任务控制块中的变量 ulNotifiedValue <em>/<br>eNotifyAction eAction ); /</em> 任务通知模式设置 */</p>
<ul>
<li><p>第三个参数支持的参数———-参数描述</p>
<ul>
<li>接收此消息的任务， 其任务控制块中的变量 ulNotifiedValue 没有变化， 即函数xTaskNotify 第 2 个参数 ulValue 没有用上。</li>
<li>接收此消息的任务， 其任务控制块中的变量 ulNotifiedValue 与函数 xTaskNotify 第 2 个参数 ulValue 实现或操作，比如ulValue=0x01， 那么变量的 ulNotifiedValue 的 bit0 = 1，<br>ulValue=0x08， 那么变量的 ulNotifiedValue 的 bit3= 1， 通过这种方式就实现了任务事件标志组</li>
<li>接收此消息的任务， 其任务控制块中的变量 ulNotifiedValue 实现加一操作，此时函数 xTaskNotify 实现的功能等效于函数xTaskNotifyGive， 函数 xTaskNotify 的第二个参数 ulValue 没有用上。 这种方式用于信号量</li>
<li>接收此消息的任务， 其任务控制块中的变量 ulNotifiedValue 被设置为函数 xTaskNotify 第 2 个参数 ulValue 的数值， 即使等待此消息的任务还没有收到上一次的数值，即数值被覆盖了。 这种方式用于消息邮箱， 相当于消息队列覆盖方式函数xQueueOverwrite()</li>
<li>如果接收此消息的任务， 其任务控制块中的变量<br>ulNotifiedValue 已经被更新，但由于接收此消息的任务还处于阻塞态等待此消息，那么变量 ulNotifiedValue 不可以被更新为函数 xTaskNotify 第 2 个参数 ulValue 的数值， ， 此时函数xTaskNotify 会返回 pdFALSE。</li>
</ul>
</li>
</ul>
<hr>
<p>如果接收此消息的任务， 其任务控制块中的变量<br>ulNotifiedValue 还没有被更新， 那么变量 ulNotifiedValue 会</p>
<h2 id="被设置为-xTaskNotify-第-2-个参数-ulValue-的数值。"><a href="#被设置为-xTaskNotify-第-2-个参数-ulValue-的数值。" class="headerlink" title="被设置为 xTaskNotify 第 2 个参数 ulValue 的数值。"></a>被设置为 xTaskNotify 第 2 个参数 ulValue 的数值。</h2><p>这种方式用于消息邮箱，相当于消息队列长度为 1 时调用函数xQueueSend().</p>
<h2 id="任务二值信号量"><a href="#任务二值信号量" class="headerlink" title="任务二值信号量"></a>任务二值信号量</h2><h2 id="任务计数信号量"><a href="#任务计数信号量" class="headerlink" title="任务计数信号量"></a>任务计数信号量</h2><h3 id="基于任务通知的计数信号量"><a href="#基于任务通知的计数信号量" class="headerlink" title="基于任务通知的计数信号量"></a>基于任务通知的计数信号量</h3><ul>
<li><p>效率更高</p>
<ul>
<li>速度提升45%</li>
</ul>
</li>
<li><p>需要的RAM空间更小</p>
</li>
<li><p>仅可用在只有一个任务等待信号量</p>
</li>
</ul>
<h3 id="计数信号量API函数"><a href="#计数信号量API函数" class="headerlink" title="计数信号量API函数"></a>计数信号量API函数</h3><ul>
<li><p>xTaskNotifyGive 用于释放信号量（ 含任务二值信号量， 任务计数信号量）</p>
<ul>
<li>任务信号量的初始计数值是 0。 任务信号量不像FreeRtos的信号量，无需单独创建即可使用</li>
</ul>
</li>
<li><p>ulTaskNotifyTake用于获取信号量</p>
</li>
</ul>
<h2 id="FreeRtos系统时钟节拍和中断管理"><a href="#FreeRtos系统时钟节拍和中断管理" class="headerlink" title="FreeRtos系统时钟节拍和中断管理"></a>FreeRtos系统时钟节拍和中断管理</h2><h3 id="FreeRtos-时钟节拍"><a href="#FreeRtos-时钟节拍" class="headerlink" title="FreeRtos 时钟节拍"></a>FreeRtos 时钟节拍</h3><ul>
<li>任何操作系统都需要提供一个时钟节拍，以供系统处理诸如延时、 超时等与时间相关的事件</li>
<li>#define configTICK_RATE_HZ</li>
<li>滴答定时器Systick</li>
</ul>
<h3 id="FreeRtos-时钟管理"><a href="#FreeRtos-时钟管理" class="headerlink" title="FreeRtos 时钟管理"></a>FreeRtos 时钟管理</h3><ul>
<li><p>时间延迟</p>
<ul>
<li>为周期性执行的任务提供延迟</li>
<li>对于抢占式调度器，让高优先级任务可以通过时间延迟函数释放 CPU 使用权， 从而让低优先级任务可以得到执行。</li>
</ul>
</li>
<li><p>FreeRtos时间相关函数</p>
<ul>
<li>vTaskDelay () 相对时间延迟</li>
<li>vTaskDelayUntil () 绝对时间延迟</li>
<li>xTaskGetTickCount 获取系统当前运行的时钟节拍数</li>
<li>xTaskGetTickCountFromISR</li>
</ul>
</li>
</ul>
<h2 id="FreeRtos事件标志组"><a href="#FreeRtos事件标志组" class="headerlink" title="FreeRtos事件标志组"></a>FreeRtos事件标志组</h2><h3 id="事件标志"><a href="#事件标志" class="headerlink" title="事件标志"></a>事件标志</h3><ul>
<li>在裸机编程中 全局变量确实方便</li>
<li>在操作系统中全局变量就要防止多任务的访问冲突</li>
<li>事件标志组可以有效地解决中断服务程序和任务之间的同步问题 减少任务之间的耦合</li>
</ul>
<h3 id="任务标志组API函数"><a href="#任务标志组API函数" class="headerlink" title="任务标志组API函数"></a>任务标志组API函数</h3><ul>
<li>xEventGroupCreate()<br>xEventGroupCreateStatic()</li>
<li>vEventGroupDelete()</li>
<li>xEventGroupWaitBits()</li>
<li>xEventGroupSetBits()<br>xEventGroupSetBitsFromISR()</li>
<li>xEventGroupClearBits()<br>xEventGroupClearBitsFromISR()</li>
<li>xEventGroupGetBits()<br>xEventGroupGetBitsFromISR()</li>
</ul>
<h3 id="任务间事件标志组的实现"><a href="#任务间事件标志组的实现" class="headerlink" title="任务间事件标志组的实现"></a>任务间事件标志组的实现</h3><h2 id="FreeRtos定时器组"><a href="#FreeRtos定时器组" class="headerlink" title="FreeRtos定时器组"></a>FreeRtos定时器组</h2><h3 id="软件定时器组，不需要使用任何硬件定时器-可以创建多个"><a href="#软件定时器组，不需要使用任何硬件定时器-可以创建多个" class="headerlink" title="软件定时器组，不需要使用任何硬件定时器 可以创建多个"></a>软件定时器组，不需要使用任何硬件定时器 可以创建多个</h3><ul>
<li><p>与硬件定时器不同，软件定时器使用指定的回调函数 在回调函数中执行相应功能</p>
</li>
<li><p>单次模式</p>
<ul>
<li>用户创建了定时器并启动了<br>定时器后， 定时时间到将不再重新执行</li>
</ul>
</li>
<li><p>周期模式</p>
<ul>
<li>按照设置的时间周期重复去执行</li>
</ul>
</li>
</ul>
<h3 id="定时器组API函数"><a href="#定时器组API函数" class="headerlink" title="定时器组API函数"></a>定时器组API函数</h3><ul>
<li>xTimerCreate 用于创建软件定时器</li>
<li>xTimerStart 用于启动软件定时器</li>
<li>pvTimerGetTimerID 用于返回使用函数 xTimerCreate 创建的软件定时器 ID</li>
</ul>
<h2 id="FreeRtos消息队列"><a href="#FreeRtos消息队列" class="headerlink" title="FreeRtos消息队列"></a>FreeRtos消息队列</h2><h3 id="消息队列概念及其作用"><a href="#消息队列概念及其作用" class="headerlink" title="消息队列概念及其作用"></a>消息队列概念及其作用</h3><ul>
<li>避免使用全局数组可能造成的任务访问冲突</li>
<li>FreeRTOS 的消息传递是数据的复制，而不是传递的数据地址</li>
<li>解决中断服务程序与任务之间消息传递的问题</li>
<li>FIFO 机制更有利于数据的处理</li>
</ul>
<h3 id="任务间消息队列的实现"><a href="#任务间消息队列的实现" class="headerlink" title="任务间消息队列的实现"></a>任务间消息队列的实现</h3><ul>
<li><p>消息队列API函数</p>
<ul>
<li>xQueueCreate 用于创建消息队列</li>
<li>xQueueSend 用于任务中消息发送xQueueSendFromISR 用于中断服务程序中消息发送</li>
<li>xQueueReceive 用于接收消息队列中的数据</li>
</ul>
</li>
</ul>
<h2 id="FreeRtos计数信号量"><a href="#FreeRtos计数信号量" class="headerlink" title="FreeRtos计数信号量"></a>FreeRtos计数信号量</h2><h3 id="多个共享资源管理"><a href="#多个共享资源管理" class="headerlink" title="多个共享资源管理"></a>多个共享资源管理</h3><h3 id="各个任务之间使用信号量实现任务的同步或者资源共享功能"><a href="#各个任务之间使用信号量实现任务的同步或者资源共享功能" class="headerlink" title="各个任务之间使用信号量实现任务的同步或者资源共享功能"></a>各个任务之间使用信号量实现任务的同步或者资源共享功能</h3><ul>
<li><p>计数信号量API函数</p>
<ul>
<li>xSemaphoreCreateCounting 创建计数信号量</li>
<li>xSemaphoreGive       在任务代码中释放信号量</li>
<li>xSemaphoreGiveFromISR 中断服务程序中释放信号量</li>
<li>xSemaphoreTake       在任务代码中获取信号量</li>
</ul>
</li>
</ul>
<h2 id="FreeRtos二值信号量"><a href="#FreeRtos二值信号量" class="headerlink" title="FreeRtos二值信号量"></a>FreeRtos二值信号量</h2><h3 id="特殊的计数信号量-即共享资源为1的时候"><a href="#特殊的计数信号量-即共享资源为1的时候" class="headerlink" title="特殊的计数信号量 即共享资源为1的时候"></a>特殊的计数信号量 即共享资源为1的时候</h3><h3 id="二值信号量API函数"><a href="#二值信号量API函数" class="headerlink" title="二值信号量API函数"></a>二值信号量API函数</h3><ul>
<li>xSemaphoreCreateBinary 用于创建二值信号量。</li>
<li>xSemaphoreGive 用于在任务代码中释放信号量</li>
<li>xSemaphoreGiveFromISR 用于中断服务程序中释放信号量</li>
<li>xSemaphoreTake 用于在任务代码中获取信号量</li>
</ul>
<h2 id="FreeRtos互斥信号量"><a href="#FreeRtos互斥信号量" class="headerlink" title="FreeRtos互斥信号量"></a>FreeRtos互斥信号量</h2><h3 id="对资源实现互斥访问"><a href="#对资源实现互斥访问" class="headerlink" title="对资源实现互斥访问"></a>对资源实现互斥访问</h3><ul>
<li><p>二值信号量也可以实现对资源的互斥访问</p>
<ul>
<li>一个任务申请成功 另一个任务释放</li>
</ul>
</li>
<li><p>互斥信号量</p>
<ul>
<li><p>同一个任务申请，同一个任务释放</p>
</li>
<li><p>同一个任务实现递归申请</p>
</li>
<li><p>API函数</p>
<ul>
<li>xSemaphoreCreateMutex 用于创建互斥信号量</li>
<li>xSemaphoreGive 用于在任务代码中释放信号量</li>
<li>xSemaphoreTake 用于在任务代码中获取信号量</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="优先级翻转"><a href="#优先级翻转" class="headerlink" title="优先级翻转"></a>优先级翻转</h3><h2 id="嵌入式实时操作系统"><a href="#嵌入式实时操作系统" class="headerlink" title="嵌入式实时操作系统"></a>嵌入式实时操作系统</h2><h3 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h3><ul>
<li>调度算法</li>
</ul>
<h3 id="任务切换-1"><a href="#任务切换-1" class="headerlink" title="任务切换"></a>任务切换</h3><ul>
<li>在基本相同的硬件内核架构，任务切换也是相似的</li>
</ul>
<h2 id="单任务系统编程框架即裸机编程的变成框架，采用的是超级循环，即应用程序是无限的循环，循环中调用相应的函数完成相应的操作的后台行为，中断服务程序处理异步事件，可看作为前台行为"><a href="#单任务系统编程框架即裸机编程的变成框架，采用的是超级循环，即应用程序是无限的循环，循环中调用相应的函数完成相应的操作的后台行为，中断服务程序处理异步事件，可看作为前台行为" class="headerlink" title="单任务系统编程框架即裸机编程的变成框架，采用的是超级循环，即应用程序是无限的循环，循环中调用相应的函数完成相应的操作的后台行为，中断服务程序处理异步事件，可看作为前台行为"></a>单任务系统编程框架即裸机编程的变成框架，采用的是超级循环，即应用程序是无限的循环，循环中调用相应的函数完成相应的操作的后台行为，中断服务程序处理异步事件，可看作为前台行为</h2><h2 id="系统上电复位后默认使用优先级分组0"><a href="#系统上电复位后默认使用优先级分组0" class="headerlink" title="系统上电复位后默认使用优先级分组0"></a>系统上电复位后默认使用优先级分组0</h2><h2 id="将这几个选项简单的累加就可以得到粗略的栈大小-当然-在系统开始任务调度之后我们可以通过实时监测调整栈的分配"><a href="#将这几个选项简单的累加就可以得到粗略的栈大小-当然-在系统开始任务调度之后我们可以通过实时监测调整栈的分配" class="headerlink" title="将这几个选项简单的累加就可以得到粗略的栈大小  当然 在系统开始任务调度之后我们可以通过实时监测调整栈的分配"></a>将这几个选项简单的累加就可以得到粗略的栈大小  当然 在系统开始任务调度之后我们可以通过实时监测调整栈的分配</h2><h2 id="这里提供的两种栈溢出检测机制都是在任务切换时进行的，但是都有自身的缺陷而检测不到某些栈溢出"><a href="#这里提供的两种栈溢出检测机制都是在任务切换时进行的，但是都有自身的缺陷而检测不到某些栈溢出" class="headerlink" title="这里提供的两种栈溢出检测机制都是在任务切换时进行的，但是都有自身的缺陷而检测不到某些栈溢出"></a>这里提供的两种栈溢出检测机制都是在任务切换时进行的，但是都有自身的缺陷而检测不到某些栈溢出</h2><h2 id="FreeRTOS-内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。-比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件，-得不到及时执行的话，后果是可想而知的。"><a href="#FreeRTOS-内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。-比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件，-得不到及时执行的话，后果是可想而知的。" class="headerlink" title="FreeRTOS 内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。 比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件， 得不到及时执行的话，后果是可想而知的。"></a>FreeRTOS 内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。 比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件， 得不到及时执行的话，后果是可想而知的。</h2><h2 id="实际应用中切不可在定时器回调函数中调用任何将定时器任务挂起的阻塞函数"><a href="#实际应用中切不可在定时器回调函数中调用任何将定时器任务挂起的阻塞函数" class="headerlink" title="实际应用中切不可在定时器回调函数中调用任何将定时器任务挂起的阻塞函数"></a>实际应用中切不可在定时器回调函数中调用任何将定时器任务挂起的阻塞函数</h2><p><em>XMind: ZEN - Trial Version</em></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/19/MOSFET/" rel="prev" title="MOSFET">
      <i class="fa fa-chevron-left"></i> MOSFET
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/27/%E5%9B%9B%E6%97%8B%E7%BF%BC%E9%A3%9E%E8%A1%8C%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="四旋翼飞行器学习笔记">
      四旋翼飞行器学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#FREERTOS"><span class="nav-number">1.</span> <span class="nav-text">FREERTOS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos任务管理"><span class="nav-number">1.1.</span> <span class="nav-text">FreeRtos任务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单任务系统·"><span class="nav-number">1.1.1.</span> <span class="nav-text">单任务系统·</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多任务系统"><span class="nav-number">1.1.2.</span> <span class="nav-text">多任务系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈"><span class="nav-number">1.1.3.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务状态"><span class="nav-number">1.1.4.</span> <span class="nav-text">任务状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务管理函数"><span class="nav-number">1.1.5.</span> <span class="nav-text">任务管理函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos任务栈大小"><span class="nav-number">1.2.</span> <span class="nav-text">FreeRtos任务栈大小</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数的嵌套调用"><span class="nav-number">1.2.1.</span> <span class="nav-text">函数的嵌套调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务切换"><span class="nav-number">1.2.2.</span> <span class="nav-text">任务切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对于M3和M4内核的MCU-任务执行过程中发生中断"><span class="nav-number">1.2.3.</span> <span class="nav-text">对于M3和M4内核的MCU 任务执行过程中发生中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈溢出检测"><span class="nav-number">1.2.4.</span> <span class="nav-text">栈溢出检测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos中断优先级"><span class="nav-number">1.3.</span> <span class="nav-text">FreeRtos中断优先级</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NVIC基础知识—-gt-嵌套向量中断控制器"><span class="nav-number">1.3.1.</span> <span class="nav-text">NVIC基础知识—-&gt;嵌套向量中断控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开关中断实现机制"><span class="nav-number">1.3.2.</span> <span class="nav-text">开关中断实现机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务抢占优先级及其分配方案"><span class="nav-number">1.4.</span> <span class="nav-text">任务抢占优先级及其分配方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#任务优先级和中断优先级"><span class="nav-number">1.4.1.</span> <span class="nav-text">任务优先级和中断优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务优先级分配方案"><span class="nav-number">1.4.2.</span> <span class="nav-text">任务优先级分配方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关函数"><span class="nav-number">1.4.3.</span> <span class="nav-text">相关函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务调度"><span class="nav-number">1.5.</span> <span class="nav-text">任务调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抢占式调度器"><span class="nav-number">1.5.1.</span> <span class="nav-text">抢占式调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间片调度器"><span class="nav-number">1.5.2.</span> <span class="nav-text">时间片调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合作式调度器"><span class="nav-number">1.5.3.</span> <span class="nav-text">合作式调度器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos临界段和开关中断"><span class="nav-number">1.6.</span> <span class="nav-text">FreeRtos临界段和开关中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#临界段，一但该部分代码开始执行，则不允许中断打断"><span class="nav-number">1.6.1.</span> <span class="nav-text">临界段，一但该部分代码开始执行，则不允许中断打断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#影响系统的实时性"><span class="nav-number">1.6.2.</span> <span class="nav-text">影响系统的实时性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos调度锁-任务锁和中断锁"><span class="nav-number">1.7.</span> <span class="nav-text">FreeRtos调度锁 任务锁和中断锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度锁"><span class="nav-number">1.7.1.</span> <span class="nav-text">调度锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断锁"><span class="nav-number">1.7.2.</span> <span class="nav-text">中断锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务锁"><span class="nav-number">1.7.3.</span> <span class="nav-text">任务锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态内存管理"><span class="nav-number">1.8.</span> <span class="nav-text">动态内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#动态内存管理是FreeRtos非常重要的一项功能-所有需要RAM空间都是通过动态内存管理从FreeRTOSconfig-h文件定义的heap空间中申请的"><span class="nav-number">1.8.1.</span> <span class="nav-text">动态内存管理是FreeRtos非常重要的一项功能 所有需要RAM空间都是通过动态内存管理从FreeRTOSconfig.h文件定义的heap空间中申请的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRTOS支持五种动态内存管理方案"><span class="nav-number">1.8.2.</span> <span class="nav-text">FreeRTOS支持五种动态内存管理方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务消息邮箱"><span class="nav-number">1.9.</span> <span class="nav-text">任务消息邮箱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务通知"><span class="nav-number">1.10.</span> <span class="nav-text">任务通知</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCB（task-control-block）任务控制块中一个-32-位的变量成员-ulNotifiedValue-是专门"><span class="nav-number">1.10.1.</span> <span class="nav-text">TCB（task control block）任务控制块中一个 32 位的变量成员 ulNotifiedValue 是专门</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务事件标志组"><span class="nav-number">1.11.</span> <span class="nav-text">任务事件标志组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BaseType-t-xTaskNotify-TaskHandle-t-xTaskToNotify-任务句柄"><span class="nav-number">1.11.1.</span> <span class="nav-text">BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, &#x2F;* 任务句柄 *&#x2F;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#被设置为-xTaskNotify-第-2-个参数-ulValue-的数值。"><span class="nav-number">1.12.</span> <span class="nav-text">被设置为 xTaskNotify 第 2 个参数 ulValue 的数值。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务二值信号量"><span class="nav-number">1.13.</span> <span class="nav-text">任务二值信号量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务计数信号量"><span class="nav-number">1.14.</span> <span class="nav-text">任务计数信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于任务通知的计数信号量"><span class="nav-number">1.14.1.</span> <span class="nav-text">基于任务通知的计数信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计数信号量API函数"><span class="nav-number">1.14.2.</span> <span class="nav-text">计数信号量API函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos系统时钟节拍和中断管理"><span class="nav-number">1.15.</span> <span class="nav-text">FreeRtos系统时钟节拍和中断管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRtos-时钟节拍"><span class="nav-number">1.15.1.</span> <span class="nav-text">FreeRtos 时钟节拍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeRtos-时钟管理"><span class="nav-number">1.15.2.</span> <span class="nav-text">FreeRtos 时钟管理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos事件标志组"><span class="nav-number">1.16.</span> <span class="nav-text">FreeRtos事件标志组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事件标志"><span class="nav-number">1.16.1.</span> <span class="nav-text">事件标志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务标志组API函数"><span class="nav-number">1.16.2.</span> <span class="nav-text">任务标志组API函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务间事件标志组的实现"><span class="nav-number">1.16.3.</span> <span class="nav-text">任务间事件标志组的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos定时器组"><span class="nav-number">1.17.</span> <span class="nav-text">FreeRtos定时器组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件定时器组，不需要使用任何硬件定时器-可以创建多个"><span class="nav-number">1.17.1.</span> <span class="nav-text">软件定时器组，不需要使用任何硬件定时器 可以创建多个</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定时器组API函数"><span class="nav-number">1.17.2.</span> <span class="nav-text">定时器组API函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos消息队列"><span class="nav-number">1.18.</span> <span class="nav-text">FreeRtos消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列概念及其作用"><span class="nav-number">1.18.1.</span> <span class="nav-text">消息队列概念及其作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务间消息队列的实现"><span class="nav-number">1.18.2.</span> <span class="nav-text">任务间消息队列的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos计数信号量"><span class="nav-number">1.19.</span> <span class="nav-text">FreeRtos计数信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多个共享资源管理"><span class="nav-number">1.19.1.</span> <span class="nav-text">多个共享资源管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各个任务之间使用信号量实现任务的同步或者资源共享功能"><span class="nav-number">1.19.2.</span> <span class="nav-text">各个任务之间使用信号量实现任务的同步或者资源共享功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos二值信号量"><span class="nav-number">1.20.</span> <span class="nav-text">FreeRtos二值信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特殊的计数信号量-即共享资源为1的时候"><span class="nav-number">1.20.1.</span> <span class="nav-text">特殊的计数信号量 即共享资源为1的时候</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二值信号量API函数"><span class="nav-number">1.20.2.</span> <span class="nav-text">二值信号量API函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRtos互斥信号量"><span class="nav-number">1.21.</span> <span class="nav-text">FreeRtos互斥信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对资源实现互斥访问"><span class="nav-number">1.21.1.</span> <span class="nav-text">对资源实现互斥访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级翻转"><span class="nav-number">1.21.2.</span> <span class="nav-text">优先级翻转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌入式实时操作系统"><span class="nav-number">1.22.</span> <span class="nav-text">嵌入式实时操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调度器"><span class="nav-number">1.22.1.</span> <span class="nav-text">调度器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务切换-1"><span class="nav-number">1.22.2.</span> <span class="nav-text">任务切换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单任务系统编程框架即裸机编程的变成框架，采用的是超级循环，即应用程序是无限的循环，循环中调用相应的函数完成相应的操作的后台行为，中断服务程序处理异步事件，可看作为前台行为"><span class="nav-number">1.23.</span> <span class="nav-text">单任务系统编程框架即裸机编程的变成框架，采用的是超级循环，即应用程序是无限的循环，循环中调用相应的函数完成相应的操作的后台行为，中断服务程序处理异步事件，可看作为前台行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统上电复位后默认使用优先级分组0"><span class="nav-number">1.24.</span> <span class="nav-text">系统上电复位后默认使用优先级分组0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将这几个选项简单的累加就可以得到粗略的栈大小-当然-在系统开始任务调度之后我们可以通过实时监测调整栈的分配"><span class="nav-number">1.25.</span> <span class="nav-text">将这几个选项简单的累加就可以得到粗略的栈大小  当然 在系统开始任务调度之后我们可以通过实时监测调整栈的分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#这里提供的两种栈溢出检测机制都是在任务切换时进行的，但是都有自身的缺陷而检测不到某些栈溢出"><span class="nav-number">1.26.</span> <span class="nav-text">这里提供的两种栈溢出检测机制都是在任务切换时进行的，但是都有自身的缺陷而检测不到某些栈溢出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FreeRTOS-内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。-比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件，-得不到及时执行的话，后果是可想而知的。"><span class="nav-number">1.27.</span> <span class="nav-text">FreeRTOS 内核源码中有多处开关全局中断的地方，这些开关全局中断会加大中断延迟时间。 比如在源码的某个地方关闭了全局中断，但是此时有外部中断触发，这个中断的服务程序就需要等到再次开启全局中断后才可以得到执行。开关中断之间的时间越长，中断延迟时间就越大，这样极其影响系统的实时性。如果这是一个紧急的中断事件， 得不到及时执行的话，后果是可想而知的。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实际应用中切不可在定时器回调函数中调用任何将定时器任务挂起的阻塞函数"><span class="nav-number">1.28.</span> <span class="nav-text">实际应用中切不可在定时器回调函数中调用任何将定时器任务挂起的阻塞函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="张怡航"
      src="/images/apple-touch-icon-next.png">
  <p class="site-author-name" itemprop="name">张怡航</p>
  <div class="site-description" itemprop="description">今天懒惰小张敲代码了吗</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张怡航</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
